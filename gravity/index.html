<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Gravity Simulator</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, 
maximum-scale=1.0">

		<link rel="stylesheet" type="text/css" href="../style.css">
	</head>
	<body>
		<script src="../three.js/build/three.min.js"></script>
		<script src="../gui/build/dat.gui.min.js"></script>

		<script type="application/javascript">
		class Simulation {
			constructor() {
				this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
				this.camera.position.x = 200;

				this.scene = new THREE.Scene();

				this.scene.fog = new THREE.FogExp2(0x445544, 0.0015);

				this.bodyGeometry = new THREE.SphereGeometry(1, 10, 10);
				this.bodyMaterial = new THREE.MeshPhongMaterial();

				this.lights = new THREE.Group();

				this.lightHemisphere = new THREE.HemisphereLight(0x335555, 0x553355);

				this.lights.add(this.lightHemisphere);

				this.scene.add(this.lights);

				this.renderer = new THREE.WebGLRenderer({antialias:true});
				this.renderer.setPixelRatio(window.devicePixelRatio);
				this.renderer.setSize(window.innerWidth, window.innerHeight);
				this.renderer.sortObjects = true;

				var simulation = this;

				function onWindowResize() {
					simulation.camera.aspect = window.innerWidth / window.innerHeight;
					simulation.camera.updateProjectionMatrix();
					simulation.renderer.setSize(window.innerWidth, window.innerHeight);
				}

				document.body.appendChild(this.renderer.domElement);
				window.addEventListener('resize', onWindowResize, false);
			
				this.time = 0;
                                this.G = 0.5;
				this.updateIncrement = 1;
				this.drawEveryFrame = true;
				this.drawTime = 0;

				this.bodiesCount = 2;
			}

			get bodiesCount() {
				return this.countBodies;
			}

			set bodiesCount(value) {
				this.countBodies = value;

				this.scene.remove(this.bodies);

				this.bodies = new THREE.Group();

				for (var i = 0; i < this.countBodies; i++) {
					var body = new THREE.Mesh(this.bodyGeometry, this.bodyMaterial.clone());
					body.position.set((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50);
					body.velocity = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
					var bodyScale = (Math.random() + 0.5) * 10;
					body.scale.set(bodyScale, bodyScale, bodyScale);
					body.material.color = new THREE.Color(Math.random(), Math.random(), Math.random());
					this.bodies.add(body);
				}

				this.scene.add(this.bodies);

				this.update();
				this.draw();
			}

			update() {
				this.time += 1;

				for (var index1 = 0; index1 < this.bodies.children.length; index1++) {
                               	        for (var index2 = 0; index2 < this.bodies.children.length; index2++) {
						var body1 = this.bodies.children[index1];
						var body2 = this.bodies.children[index2];

						if (body1 != body2) {
							var g = -1 * this.G * body1.scale.x * body2.scale.x * (1 / Math.pow(body1.position.distanceTo(body2.position), 3));

							var a1 = g / body1.scale.x;
							//var a2 = g / body2.scale.x;

							var pos1 = body1.position;
							var pos2 = body2.position;

							var vec1 = new THREE.Vector3(pos1.x - pos2.x, pos1.y - pos2.y, pos1.z - pos2.z);
							//var vec2 = new THREE.Vector3(pos2.x - pos1.x, pos2.y - pos1.y, pos2.z - pos1.z);

							vec1.multiplyScalar(a1);
							//vec2.multiplyScalar(a2);

							body1.velocity.add(vec1);
						}		
               	                        }
                                }

				for (var i = 0; i < this.bodies.children.length; i++) {
					this.bodies.children[i].position.add(this.bodies.children[i].velocity);
				}
			}

			draw() {
				var sceneCOM = new THREE.Vector3();

				for (var i = 0; i < this.bodies.children.length; i++) {
					sceneCOM.add(this.bodies.children[i].position);
				}

				sceneCOM.divideScalar(this.bodies.children.length);

				this.camera.lookAt(sceneCOM);

				this.renderer.render(this.scene, this.camera);

				this.drawTime += 1;

				if (this.drawTime % Math.round(this.updateIncrement) == 0) {
					this.update();
				}
			}
		}

		var simulation = new Simulation();

		var GUI = new dat.GUI({height: 3 * 32 - 1});

		GUI.add(simulation, "bodiesCount");

		GUI.add(simulation, "G");

		GUI.add(simulation, "updateIncrement");

		GUI.add(simulation, "drawEveryFrame");

		function loop() {
			requestAnimationFrame(loop);

			if (simulation.drawEveryFrame) {
				simulation.draw();
			}
		}

		loop();
		</script>
	</body>
</html>
